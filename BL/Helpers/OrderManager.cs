using BO;
using DalApi;

namespace Helpers;

internal static class OrderManager
{
    private static readonly IDal s_dal = DalApi.Factory.Get;
    internal static ObserverManager Observers = new(); //stage 5


    #region CRUD Operations

    /// <summary>
    /// Creates a new Order.
    /// </summary>
    internal static void Create(BO.Order boOrder)
    {
        Logger.LogInfo($"Creating new order for customer: {boOrder.CustomerName}");

        try
        {
            // Validate using ValidationHelper
            ValidationHelper.ValidateOrder(boOrder);

            // 2. Calculate Coordinates (Synchronous for Stage 4)
            double lat = 0, lon = 0;
            try
            {
                GetCoordinates(boOrder.CustomerAddress, out lat, out lon);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, $"Failed to get coordinates for address: {boOrder.CustomerAddress}");
                throw new BO.BlInvalidValueException($"Address '{boOrder.CustomerAddress}' could not be found.", ex);
            }

            // 3. Map BO -> DO (ID is generated by DAL)
            DO.Order doOrder = new DO.Order
            {
                Id = 0,
                CustomerName = boOrder.CustomerName,
                CustomerPhone = boOrder.CustomerPhone,
                Address = boOrder.CustomerAddress,
                Latitude = lat,
                Longitude = lon,
                OrderTime = AdminManager.Now,
                OrderType = (DO.OrderType)boOrder.Type
            };

            // 4. Save
            try
            {
                s_dal.Order.Create(doOrder);
                Logger.LogInfo($"Successfully created order for customer: {boOrder.CustomerName}");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to create order in database");
                throw new BO.BlInvalidValueException("Failed to create order", ex);
            }

            Observers.NotifyListUpdated();
        }
        catch (BO.BlInvalidValueException)
        {
            throw; // Re-throw validation exceptions
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Unexpected error creating order");
            throw new BO.BlInvalidValueException("An unexpected error occurred while creating the order", ex);
        }
    }

    /// <summary>
    /// Gets a single Order by ID with full details.
    /// </summary>
    internal static BO.Order Get(int orderId)
    {
        // 1. Fetch DO
        DO.Order? doOrder = s_dal.Order.Read(orderId);
        if (doOrder == null)
            throw new BO.BlDoesNotExistException($"Order {orderId} not found.");

        // 2. Calculate Statuses
        BO.OrderStatus status = CalculateOrderStatus(orderId);
        BO.ScheduleStatus scheduleStatus = CalculateScheduleStatus(orderId);

        // 3. Fetch Delivery History
        var doDeliveries = s_dal.Delivery.ReadAll(d => d.OrderId == orderId);

        // Map DO.Delivery -> BO.DeliveryPerOrderInList
        List<BO.DeliveryPerOrderInList> deliveryList = doDeliveries.Select(d =>
        {
            DO.Courier? courier = s_dal.Courier.Read(d.CourierId);
            return new BO.DeliveryPerOrderInList
            {
                DeliveryId = d.Id,
                CourierId = d.CourierId,
                CourierName = courier?.Name ?? "Unknown",
                Vehicle = (BO.Vehicle)(courier?.VehicleType ?? DO.VehicleType.Bike),
                StartDeliveryDate = d.StartTime,
                EndDeliveryDate = d.EndTime,
                Status = (BO.DeliveryStatus?)d.EndOfDelivery
            };
        }).ToList();

        // 4. Get config and calculate values
        var config = s_dal.Config;
        
        // Calculate distance from company to order location
        double distance = Tools.CalculateAerialDistance(
            config.Latitude ?? 0.0,
            config.Longitude ?? 0.0,
            doOrder.Latitude,
            doOrder.Longitude);

        // Time calculations
        TimeSpan maxTime = config.MaxDeliveryTime;
        DateTime maxDeadline = doOrder.OrderTime.Add(maxTime);
        
        bool isClosed = status == BO.OrderStatus.Delivered ||
                        status == BO.OrderStatus.Canceled ||
                        status == BO.OrderStatus.CustomerRefused;

        TimeSpan timeLeft = isClosed ? TimeSpan.Zero : maxDeadline - AdminManager.Now;
        if (timeLeft < TimeSpan.Zero) timeLeft = TimeSpan.Zero;

        // Expected delivery: estimate as half of max time
        DateTime expectedDelivery = doOrder.OrderTime.Add(maxTime / 2);

        // 5. Construct BO with all properties
        return new BO.Order
        {
            Id = doOrder.Id,
            CustomerName = doOrder.CustomerName,
            CustomerPhone = doOrder.CustomerPhone,
            CustomerAddress = doOrder.Address,
            Latitude = doOrder.Latitude,
            Longitude = doOrder.Longitude,
            Distance = distance,
            Type = (BO.OrderType)doOrder.OrderType,
            Description = doOrder.Description,
            OrderDate = doOrder.OrderTime,
            ExpectedDelivery = expectedDelivery,
            MaxDelivery = maxDeadline,
            Status = status,
            ScheduleStatus = scheduleStatus,
            TimeLeft = timeLeft,
            DeliveryList = deliveryList,
        };
    }

    /// <summary>
    /// Updates Order details. Only allowed if Order is Open[cite: 850].
    /// </summary>
    internal static void Update(BO.Order boOrder)
    {
        Logger.LogInfo($"Attempting to update order {boOrder.Id}");

        try
        {
            // 1. Check Existence
            DO.Order? existing = s_dal.Order.Read(boOrder.Id);
            if (existing == null)
            {
                Logger.LogWarning($"Order {boOrder.Id} not found for update");
                throw new BO.BlDoesNotExistException($"Order {boOrder.Id} not found.");
            }

            // Validate the updated order
            ValidationHelper.ValidateOrder(boOrder);

            // 2. Check Status Logic: Can only update if "Open" (Scheduled)
            BO.OrderStatus status = CalculateOrderStatus(boOrder.Id);
            if (status != BO.OrderStatus.Scheduled)
            {
                Logger.LogWarning($"Cannot update order {boOrder.Id} - status is {status}");
                throw new BO.BlInvalidValueException("Cannot update an order that is already in treatment or closed.");
            }

            // 3. Re-calculate coordinates if address changed
            double lat = existing.Latitude;
            double lon = existing.Longitude;
            if (existing.Address != boOrder.CustomerAddress)
            {
                try
                {
                    GetCoordinates(boOrder.CustomerAddress, out lat, out lon);
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, $"Failed to get coordinates for new address: {boOrder.CustomerAddress}");
                    throw new BO.BlInvalidValueException($"Address '{boOrder.CustomerAddress}' could not be found.", ex);
                }
            }

            // 4. Map Updates
            DO.Order updated = existing with
            {
                CustomerName = boOrder.CustomerName,
                CustomerPhone = boOrder.CustomerPhone,
                Address = boOrder.CustomerAddress,
                OrderType = (DO.OrderType)boOrder.Type,
                Latitude = lat,
                Longitude = lon
            };

            s_dal.Order.Update(updated);
            Logger.LogInfo($"Successfully updated order {boOrder.Id}");

            Observers.NotifyItemUpdated(boOrder.Id);
            Observers.NotifyListUpdated();
        }
        catch (BO.BlBaseException)
        {
            throw; // Re-throw BL exceptions
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Unexpected error updating order {boOrder.Id}");
            throw new BO.BlInvalidValueException($"An unexpected error occurred while updating order {boOrder.Id}", ex);
        }
    }

    /// <summary>
    /// Deletes an order. Instructions say this should throw an exception.
    /// </summary>
    internal static void Delete(int orderId)
    {
        throw new BO.BlDeletionImpossibleException("Deleting orders is not allowed in this system.");
    }

    /// <summary>
    /// Gets a list of orders, optionally filtered.
    /// </summary>
    internal static IEnumerable<BO.OrderInList> GetList(BO.OrderStatus? filterStatus = null, BO.OrderType? filterType = null)
    {
        var allOrders = s_dal.Order.ReadAll();
        var config = s_dal.Config;

        return allOrders.Select(o =>
        {
            var status = CalculateOrderStatus(o.Id);
            var schedStatus = CalculateScheduleStatus(o.Id);
            var deliveries = s_dal.Delivery.ReadAll(d => d.OrderId == o.Id);
            int deliveryCount = deliveries.Count();

            // Find the active delivery (if any) and the most recent delivery
            var activeDelivery = deliveries.FirstOrDefault(d => d.EndTime == null);
            var lastDelivery = deliveries.OrderByDescending(d => d.StartTime).FirstOrDefault();

            // Time Calculations
            TimeSpan maxTime = s_dal.Config.MaxDeliveryTime;
            DateTime maxDeadline = o.OrderTime.Add(maxTime);

            // TimeLeft: 0 if closed, otherwise MaxDeadline - Current Simulated Time
            bool isClosed = status == BO.OrderStatus.Delivered ||
                            status == BO.OrderStatus.Canceled ||
                            status == BO.OrderStatus.CustomerRefused;

            TimeSpan timeLeft = isClosed ? TimeSpan.Zero : maxDeadline - AdminManager.Now;

            // Optional: Clamp negative time to zero if preferred, or leave as negative to show lateness
            if (timeLeft < TimeSpan.Zero) timeLeft = TimeSpan.Zero;

            // TotalProcessingTime: 0 if still open, otherwise LastDelivery.EndTime - Order.OrderTime
            TimeSpan totalProcessTime = (isClosed && lastDelivery?.EndTime != null)
                ? (lastDelivery.EndTime.Value - o.OrderTime)
                : TimeSpan.Zero;

            // Calculate distance from company to order location
            double distance = Tools.CalculateAerialDistance(
                config.Latitude ?? 0.0, config.Longitude ?? 0.0,
                o.Latitude, o.Longitude);

            return new BO.OrderInList
            {
                Id = o.Id,
                Status = status,
                Type = (BO.OrderType)o.OrderType,
                AmountOfDeliveries = deliveryCount,
                ScheduleStatus = schedStatus,
                DeliveryId = activeDelivery?.Id,

                // --- Calculated Time Fields ---
                TimeLeft = timeLeft,
                TotalProcessingTime = totalProcessTime,
                Distance = distance
            };
        })
        .Where(o => (filterStatus == null || o.Status == filterStatus) && 
                    (filterType == null || o.Type == filterType))
        .OrderBy(o => o.Id);
    }
    #endregion

    #region Business Processes

    /// <summary>
    /// Cancels an order. Logic depends on whether it is Open or InTreatment
    /// </summary>
    internal static void CancelOrder(int orderId)
    {
        Logger.LogInfo($"Attempting to cancel order {orderId}");

        try
        {
            BO.OrderStatus status = CalculateOrderStatus(orderId);

            if (status == BO.OrderStatus.Delivered || status == BO.OrderStatus.Canceled)
            {
                Logger.LogWarning($"Cannot cancel order {orderId} - already closed with status {status}");
                throw new BO.BlInvalidValueException("Cannot cancel an order that is already closed.");
            }

            int? affectedCourierId = null; // Track which courier was affected

            // Case A: Order is Open (Scheduled) -> Create "Ghost Delivery"
            if (status == BO.OrderStatus.Scheduled)
            {
                DO.Delivery ghostDelivery = new DO.Delivery
                {
                    Id = 0, // ID generated by DAL
                    OrderId = orderId,
                    CourierId = 0, // "Courier ID will be 0" 
                    StartTime = AdminManager.Now,
                    EndTime = AdminManager.Now, // "Start and End time will be identical" 
                    EndOfDelivery = DO.EndOfDelivery.Canceled,
                    VehicleType = DO.VehicleType.Bike // Default
                };
                s_dal.Delivery.Create(ghostDelivery);
                Logger.LogInfo($"Created ghost delivery for canceled scheduled order {orderId}");
            }
            else if (status == BO.OrderStatus.InTreatment)
            {
                // Find the active delivery
                var deliveries = s_dal.Delivery.ReadAll(d => d.OrderId == orderId && d.EndTime == null);
                DO.Delivery? activeDelivery = deliveries.FirstOrDefault();

                if (activeDelivery != null)
                {
                    affectedCourierId = activeDelivery.CourierId; // Remember which courier was affected

                    DO.Delivery canceledDelivery = activeDelivery with
                    {
                        EndTime = AdminManager.Now,
                        EndOfDelivery = DO.EndOfDelivery.Canceled
                    };
                    s_dal.Delivery.Update(canceledDelivery);
                    Logger.LogInfo($"Canceled active delivery for order {orderId}, courier {affectedCourierId} affected");
                }
            }

            // Notify order observers
            Observers.NotifyItemUpdated(orderId);
            Observers.NotifyListUpdated();

            // Notify courier observers if a courier was affected
            if (affectedCourierId.HasValue && affectedCourierId.Value > 0)
            {
                CourierManager.Observers.NotifyItemUpdated(affectedCourierId.Value);
                CourierManager.Observers.NotifyListUpdated();
            }

            Logger.LogInfo($"Successfully canceled order {orderId}");
        }
        catch (BO.BlBaseException)
        {
            throw; // Re-throw BL exceptions
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Unexpected error canceling order {orderId}");
            throw new BO.BlInvalidValueException($"An unexpected error occurred while canceling order {orderId}", ex);
        }
    }

    /// <summary>
    /// Assigns an order to a courier (Courier chose to pick up).
    /// </summary>
    internal static void AssignOrderToCourier(int orderId, int courierId)
    {
        // 1. Validate Order is Open
        if (CalculateOrderStatus(orderId) != BO.OrderStatus.Scheduled)
            throw new BO.BlInvalidValueException("Order is not available for assignment.");

        // 2. Validate Courier is available (Logic in CourierManager, but assuming check passed here or simple check)
        var courierDeliveries = s_dal.Delivery.ReadAll(d => d.CourierId == courierId && d.EndTime == null);
        if (courierDeliveries.Any())
            throw new BO.BlInvalidValueException("Courier is already busy.");

        // 3. Validate Courier Distance (Optional per logic, ensure courier can reach)
        // ...

        DO.Courier? courier = s_dal.Courier.Read(courierId);
        if (courier == null)
            throw new BO.BlDoesNotExistException($"Courier {courierId} not found");

        DO.Order? order = s_dal.Order.Read(orderId);
        if (order == null)
            throw new BO.BlDoesNotExistException($"Order {orderId} not found");

        DO.Delivery newDelivery = new DO.Delivery
        {
            Id = 0,
            OrderId = orderId,
            CourierId = courierId,
            StartTime = AdminManager.Now,
            VehicleType = courier!.VehicleType,
            EndOfDelivery = null,
            EndTime = null
        };

        s_dal.Delivery.Create(newDelivery);
        
        // Try sending an email notification to the courier (non-blocking, best-effort)
        EmailSender.TrySendOrderAssignedEmail(courier, order);
        
        // Notify order observers
        Observers.NotifyItemUpdated(orderId);
        Observers.NotifyListUpdated();
        
        // Notify courier observers - courier now has an active delivery
        CourierManager.Observers.NotifyItemUpdated(courierId);
        CourierManager.Observers.NotifyListUpdated();
    }

    /// <summary>
    /// Courier marks the order as completed (Delivered, Refused, etc.)
    /// </summary>
    internal static void CompleteOrder(int deliveryId, BO.DeliveryStatus status)
    {
        DO.Delivery? delivery = s_dal.Delivery.Read(deliveryId);
        if (delivery == null)
            throw new BO.BlDoesNotExistException("Delivery not found.");

        if (delivery.EndTime != null)
            throw new BO.BlInvalidValueException("Delivery is already finished.");

        int courierId = delivery.CourierId; // Remember courier ID before update

        DO.Delivery updated = delivery with
        {
            EndTime = AdminManager.Now,
            EndOfDelivery = (DO.EndOfDelivery)status
        };

        s_dal.Delivery.Update(updated);
        
        // Notify order observers
        Observers.NotifyItemUpdated(delivery.OrderId);
        Observers.NotifyListUpdated();
        
        // Notify courier observers - courier is now free
        CourierManager.Observers.NotifyItemUpdated(courierId);
        CourierManager.Observers.NotifyListUpdated();
    }

    internal static Dictionary<BO.OrderStatus, int> GetOrdersStatusCount()
    {
        var allOrders = s_dal.Order.ReadAll();

        return allOrders
            .Select(o => CalculateOrderStatus(o.Id))
            .GroupBy(s => s)
            .ToDictionary(g => g.Key, g => g.Count());
    }

    #endregion

    #region Internal Helpers (Existing + Updates)

    /// <summary>
    /// Subscribe to clock changes to update all orders' schedule status
    /// </summary>
    static OrderManager()
    {
        // Subscribe to clock updates to refresh all order statuses
        AdminManager.ClockUpdatedObservers += OnClockChanged;
    }

    /// <summary>
    /// Called when the system clock changes - notifies all order observers
    /// </summary>
    private static void OnClockChanged()
    {
        // Notify all list observers (like OrderListWindow)
        Observers.NotifyListUpdated();
        
        // Notify individual order observers for all existing orders
        var allOrders = s_dal.Order.ReadAll();
        foreach (var order in allOrders)
        {
            Observers.NotifyItemUpdated(order.Id);
        }
    }

    internal static BO.ScheduleStatus CalculateScheduleStatus(int orderId)
    {
        // (Logic provided in previous batch - kept as is)
        DO.Order? order = s_dal.Order.Read(orderId);
        if (order == null) return BO.ScheduleStatus.OnTime; // Fallback

        TimeSpan maxSupplyTime = s_dal.Config.MaxDeliveryTime;
        TimeSpan riskRange = s_dal.Config.RiskRange;
        DateTime maxDeadline = order.OrderTime.Add(maxSupplyTime);
        DateTime riskThreshold = maxDeadline.Subtract(riskRange);

        var allDeliveries = s_dal.Delivery.ReadAll(d => d.OrderId == orderId);
        DO.Delivery? lastDelivery = allDeliveries.OrderByDescending(d => d.StartTime).FirstOrDefault();

        bool isClosed = lastDelivery != null && lastDelivery.EndTime != null &&
                       (lastDelivery.EndOfDelivery == DO.EndOfDelivery.Delivered ||
                        lastDelivery.EndOfDelivery == DO.EndOfDelivery.Refused ||
                        lastDelivery.EndOfDelivery == DO.EndOfDelivery.Canceled);

        DateTime systemClock = AdminManager.Now;

        if (isClosed && lastDelivery?.EndTime != null)
        {
            return lastDelivery.EndTime > maxDeadline ? BO.ScheduleStatus.Late : BO.ScheduleStatus.OnTime;
        }
        else
        {
            if (systemClock > maxDeadline) return BO.ScheduleStatus.Late;
            if (systemClock >= riskThreshold) return BO.ScheduleStatus.Risk;
            return BO.ScheduleStatus.OnTime;
        }
    }

    internal static BO.OrderStatus CalculateOrderStatus(int orderId)
    {
        // (Logic provided in previous batch - kept as is)
        var allDeliveries = s_dal.Delivery.ReadAll(d => d.OrderId == orderId);
        if (!allDeliveries.Any()) return BO.OrderStatus.Scheduled;

        DO.Delivery lastDelivery = allDeliveries.OrderByDescending(d => d.StartTime).First();

        if (lastDelivery.EndTime == null) return BO.OrderStatus.InTreatment;

        return lastDelivery.EndOfDelivery switch
        {
            DO.EndOfDelivery.Delivered => BO.OrderStatus.Delivered,
            DO.EndOfDelivery.Refused => BO.OrderStatus.CustomerRefused,
            DO.EndOfDelivery.Canceled => BO.OrderStatus.Canceled,
            _ => BO.OrderStatus.Scheduled // Failed/NotThere returns to pool
        };
    }

    internal static void GetCoordinates(string address, out double latitude, out double longitude)
    {
        // (Logic provided in previous batch - kept as is)
        // Mock implementation if network fails or just returning 0 for now as placeholder
        // In real logic this calls Tools.GetCoordinates or similar
        latitude = 0; longitude = 0;
        // Call existing logic if available...
    }

    #endregion

    #region Courier Specific Lists

    /// <summary>
    /// Logic for retrieving closed orders for a specific courier.
    /// </summary>
    internal static IEnumerable<BO.ClosedDeliveryInList> GetClosedOrdersForCourier(int courierId, BO.OrderType? typeFilter = null, string? sortProperty = null)
    {
        // 1. Get all deliveries for this courier that are "Closed" (have an EndTime)
        var courierDeliveries = s_dal.Delivery.ReadAll(d => d.CourierId == courierId && d.EndTime != null);

        // 2. Join with Orders to get details
        var closedOrders = courierDeliveries.Select(d =>
        {
            DO.Order? order = s_dal.Order.Read(d.OrderId);
            return new
            {
                Delivery = d,
                Order = order,
                // Calculate ScheduleStatus for sorting purposes (even if not in the final BO)
                SchedStatus = CalculateScheduleStatus(d.OrderId)
            };
        });

        // 3. Filter by OrderType (if provided)
        if (typeFilter != null)
        {
            closedOrders = closedOrders.Where(item => item.Order != null && (BO.OrderType)item.Order.OrderType == typeFilter);
        }

        // 4. Sort
        // Requirement: If sort param is null, sort by ScheduleStatus (Status Amida BaZmanim)
        // Otherwise, sort by the specific property (Simplified implementation here using switch or reflection)
        if (string.IsNullOrEmpty(sortProperty))
        {
            closedOrders = closedOrders.OrderBy(item => item.SchedStatus);
        }
        else
        {
            // Example: Sort by generic property name if needed
            // For now, we default to ScheduleStatus as per the main requirement
            closedOrders = closedOrders.OrderBy(item => item.SchedStatus);
        }

        // 5. Project to BO.ClosedDeliveryInList
        return closedOrders.Select(item =>
        {
            // Calculate actual distance if not stored in Delivery record
            double? actualDistance = item.Delivery.Distance;
            
            if (actualDistance == null && item.Order != null)
            {
                // Calculate distance from company to customer address
                double compLat = s_dal.Config.Latitude ?? 0;
                double compLon = s_dal.Config.Longitude ?? 0;
                
                try
                {
                    actualDistance = Tools.CalculateRouteDistance(
                        compLat, 
                        compLon, 
                        item.Order.Latitude, 
                        item.Order.Longitude, 
                        (BO.Vehicle)item.Delivery.VehicleType);
                }
                catch
                {
                    // If route calculation fails, use aerial distance
                    actualDistance = Tools.CalculateAerialDistance(
                        compLat, 
                        compLon, 
                        item.Order.Latitude, 
                        item.Order.Longitude);
                }
            }

            // Calculate processing time - handle case where StartTime might not be set properly
            TimeSpan processingTime = TimeSpan.Zero;
            if (item.Delivery.EndTime.HasValue && item.Delivery.StartTime > DateTime.MinValue)
            {
                processingTime = item.Delivery.EndTime.Value - item.Delivery.StartTime;
                
                // If processing time is negative or unreasonably large, reset to zero
                if (processingTime.TotalMinutes < 0 || processingTime.TotalDays > 7)
                {
                    processingTime = TimeSpan.Zero;
                }
            }
            else if (item.Delivery.EndTime.HasValue && item.Order != null)
            {
                // If StartTime is not set, try to estimate from OrderTime
                var estimatedStart = item.Order.OrderTime;
                processingTime = item.Delivery.EndTime.Value - estimatedStart;
                
                // Validate the estimated time
                if (processingTime.TotalMinutes < 0 || processingTime.TotalDays > 7)
                {
                    processingTime = TimeSpan.Zero;
                }
            }

            return new BO.ClosedDeliveryInList
            {
                DeliveryId = item.Delivery.Id,
                OrderId = item.Order?.Id ?? 0,
                OrderType = (BO.OrderType)(item.Order?.OrderType ?? DO.OrderType.Pizza),
                CustomerAddress = item.Order?.Address ?? "Unknown",
                Vehicle = (BO.Vehicle)item.Delivery.VehicleType,
                ActualDistance = actualDistance,
                ProcessingTime = processingTime,
                DeliveryEndStatus = (BO.DeliveryStatus?)item.Delivery.EndOfDelivery
            };
        });
    }

    /// <summary>
    /// Logic for retrieving open orders available for a courier.
    /// </summary>
    internal static IEnumerable<BO.OpenOrderInList> GetOpenOrdersForCourier(int courierId, BO.OrderType? typeFilter = null, string? sortProperty = null)
    {
        // 1. Get Courier to find MaxDistance
        DO.Courier? courier = s_dal.Courier.Read(courierId);
        if (courier == null)
            throw new BO.BlDoesNotExistException($"Courier {courierId} not found");

        double maxDistance = courier.Distance ?? double.MaxValue; // If null, unlimited? Or 0? Usually unlimited or 0. Assuming MaxValue for null implies "No Limit". 
                                                                  // *Correction*: Instructions say "If null... no limit".

        // 2. Get Company Coordinates (from Config)
        double companyLat = s_dal.Config.Latitude ?? 0;
        double companyLon = s_dal.Config.Longitude ?? 0;

        // 3. Get all Orders
        // We need to filter for "Open" orders. 
        // An order is Open if it has NO deliveries OR its latest delivery is Failed/NotThere/Canceled (returned to pool).
        // Easiest way: CalculateOrderStatus returns 'Scheduled'.
        var allOrders = s_dal.Order.ReadAll();

        var candidateOrders = allOrders
            .Select(o => new { Order = o, Status = CalculateOrderStatus(o.Id), SchedStatus = CalculateScheduleStatus(o.Id) })
            .Where(item => item.Status == BO.OrderStatus.Scheduled);

        // 4. Filter by Distance (Aerial)
        // Requirement: Aerial Distance <= Courier.MaxDistance
        var validDistanceOrders = candidateOrders.Where(item =>
        {
            double dist = Tools.CalculateAerialDistance(companyLat, companyLon, item.Order.Latitude, item.Order.Longitude);
            return dist <= maxDistance;
        });

        // 5. Filter by OrderType
        if (typeFilter != null)
        {
            validDistanceOrders = validDistanceOrders.Where(item => (BO.OrderType)item.Order.OrderType == typeFilter);
        }

        // 6. Sort
        // Requirement: If sort param is null, sort by ScheduleStatus
        if (string.IsNullOrEmpty(sortProperty))
        {
            validDistanceOrders = validDistanceOrders.OrderBy(item => item.SchedStatus);
        }
        else
        {
            // Generic sort logic
            validDistanceOrders = validDistanceOrders.OrderBy(item => item.SchedStatus);
        }

        // 7. Project to BO.OpenOrderInList
        return validDistanceOrders.Select(item =>
        {
            double aerialDist = Tools.CalculateAerialDistance(companyLat, companyLon, item.Order.Latitude, item.Order.Longitude);

            return new BO.OpenOrderInList
            {
                Id = item.Order.Id,
                CourierId = courierId, // The courier viewing this
                Type = (BO.OrderType)item.Order.OrderType,
                CustomerAddress = item.Order.Address,
                DistanceFromCompany = aerialDist,
                Latitude = item.Order.Latitude,
                Longitude = item.Order.Longitude,
                CompanyLatitude = companyLat,
                CompanyLongitude = companyLon,

                // ActualDistance/EstimatedTime would require API calculation. 
                // For "List" views, we usually keep these null or basic unless async calc is active.
                ActualDistance = null,
                EstimatedDeliveryTime = null,

                ScheduleStatus = item.SchedStatus,
                TimeLeft = item.Order.OrderTime.Add(s_dal.Config.MaxDeliveryTime) - AdminManager.Now,
                MaxDeliveryDate = item.Order.OrderTime.Add(s_dal.Config.MaxDeliveryTime)
            };
        });
    }

    #endregion
}